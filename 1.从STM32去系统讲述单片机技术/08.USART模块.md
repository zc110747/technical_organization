# **08.USART模块**

## **8.1 USART模块和通讯接口**
USART(通用同步异步收发器)是可以灵活的与外部设备进行数据交互的，支持全双工和半双工，同步和异步收发的通讯模块。USART在嵌入式产品中应用广泛，通过调试信息，连接蓝牙，wifi等外设模块，通过自定义协议和其它设备交互，都可能使用到USART接口。<br />

### **8.1.1 通讯接口详解**
USART对于芯片I/O输出的是TTL电平，不过为了可靠性，也可以通过外部扩展支持RS232, RS485和RS422等多种通讯接口, 在进行连接时一定要注意不能混用，否则有损坏器件的风险。<br />

1. TTL是芯片I/O输出的电平，因此对于逻辑电平和I/O的检测一致，即**电压0v表示逻辑0，电压3.3v表示逻辑1**。 TTL的RX，TX分开独立工作，所以为全双工，不过TTL为纯芯片的I/O输出控制，抗干扰能力差，所以主要用于短距离通讯，如板内的芯片通讯，或者仅作为调试口打印输出。<br />
2. RS232在软件使用上基本和TTL一致，所以也是全双工通讯，在设备的两端都增加转换芯片(如MAX232)进行了电平的转换，即**电压+3~+15V表示逻辑0，电压-3~-15V表示逻辑1**，这样电平的差值可以很大概率防止翻转，增强了抗干扰能力，可以一定程度上增加传输距离，一般用于20m以内的板间传输，也是在硬件设计中常用的开发中常用的器件。<br />
3. RS485则是将TX，RX信号转换为差分的A， B两个信号，根据A, B两个信号的电平差值进行区分，**电压差为+2~+6V表示逻辑1, 电压差为-2~-6V表示逻辑0**, 通过差分提高了抗共模能力，因此抗干扰能力比RS232更强，传输距离更远。不过RS485需要通过I/O控制接收和发送，所以RX和TX同时只有一个能工作，因此只能半双工，适合应用于主从通讯的模式。<br />
4. RS422则是由两路RS485分别处理TX和RX信号，RX和TX能够同时工作，因此和RS232一样支持全双工通讯，且和RS485一样具有较强的抗干扰能力，支持远程传输，不过器件价格也会更高，需要根据应用需求选择使用。<br />

上面讲解了硬件相关的知识，可以发现如果错误的将不同接口进行连接，就会将错误的电平加载到器件或芯片上，发生损坏，所以在使用中一定要确认，特别是现在USB转串口模块并没有说明，很容易发生问题。

### **8.1.1 串口特性说明**
对于USART特性中比较重要的就是串口基础特性。<br />

1. 波特率，设备两端约定的用于解析数据的时序，常用的有115200, 57600, 9600等，如果双方设定不一致则没法正常解析数据。
2. 数据位，定义通讯中数据位的长度，一般支持7/8bit数据，对于STM32的串口来说，配置的是字长(数据位+可选的奇偶校验位), 且只支持8/9bit, 也就是以8bit数据位为例，**不开奇偶校验位，字长配置位UART_WORDLENGTH_8B，开启后配置为UART_WORDLENGTH_9B**, 需要格外注意.
3. 停止位，定义结束位的长度，支持1/2/0.5/1.5个停止位，其中最常用的停止位为1.
4. 奇偶校验位，包含奇校验，偶校验和无校验三个模式，其中奇校验用于满足数据内部有奇数个1，偶校验类似，无校验则只发送数据位。<br />

知晓了串口的波特率，字长和停止位信息，大致可以计算出串口接收一个字节需要的时间，以115200波特率，8bit字长，1个停止位为例，一个字节需要时间为1/115200\*(1 + 8 + 1)\*10^6us=86.8us，就需要快速进行接收读取。而9600比特率，一个字节传输需要时间为1/9600\*(1 + 8 + 1)\*10^3ms=1.04ms，发送完成一个字节就需要占用大量时间，因此产品应用时就要根据实际情况进行配置使用。<br />
1. 高波特率的应用，使用轮询或者中断接收，就需要保证在86.8us内将USARTx->DR内数据读出，否则就会发生ORE(Overrun error), 发生数据丢失，在实际应用中，可以降低波特率，如9600就差不多1ms接收一个字节数据，或者直接使用DMA+空闲中断读取。<br />
2. 对于低波特率通讯应用，则发送会占用大量时间，这时就适合使用缓存+发送完成中断模式或直接使用DMA发送数据。<br />

### **8.1.3 串口流控功能**
对于串口来说，硬件流控虽然并不是常用的功能，但在某些情况下，通过流控，接收端可以控制发送端的数据发送，当数据未出时，让发送端等待，避免数据发出，从而避免溢出导致的数据丢失，此外也可以对于低功耗设备间的通讯，也可以通过CTS引脚限制先上电设备的通讯，避免在启动时的串口数据导致芯片工作异常，对于STM32芯片的流控设计，两端的功能如下.

1. nRTS对应RX数据端，即接收引脚，低有效，如果打开RTS流控，则在接收到数据且未读出时(RXNE置位)，RTS对应I/O拉高，当数据读出时拉低。
2. nCTS对应TX数据端，即发送引脚，低有效，如果打开CTS流控，且检测到CTS为高电平，则下一帧数据不被发出，知道检测到CTS为低电平。

我们正常使用中，就是将发送端的nCTS和接收端的nRTS连接，这样当接收端收到数据未读出时，就会拉高nRTS, 同时发送端的nCTS也会拉高，则停止发送数据(此时TXE和TC不会置位，发送时会检测这两个状态)，当接收端读出后，则拉低nRTS，发送端的nCTS也会拉低，这时数据可以发送，从而确保接收端数据不会溢出，流控功能需要发送端和接收端同时支持才能正常工作，因此至少需多占用发送端和接收端各一个指定I/O。

## **8.2 使用USART模块进行通讯**

### **8.2.1 USART基础收发**
使用USART模块进行数据收发并不困难，按照单片机开发的通用流程：

1. 使能GPIO和USART模块的时钟。
2. 配置对应GPIO，以及USART模块，符合工作的要求。
3. 调用发送和接收接口完成usart数据的接收和发送。

其中初始化部分HAL库的实现的没有问题，不过对于数据发送和接收，可以看到上面对效率是有要求的，特别是中断中，而STM32的HAL库实现的就特别冗余，我个人更习惯标准库的写法，具体实现如下.<br />
时钟和GPIO的初始化和配置如下。<br />
```c
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(huart->Instance==USART1)
  {
    //使能GPIO和USART1的时钟
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_USART1_CLK_ENABLE();

    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
  }
}
```
配置USART模块功能。<br />
```c
BaseType_t usart_hardware_init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;                  //波特率115200
    huart1.Init.WordLength = UART_WORDLENGTH_8B;    //数据为8bit
    huart1.Init.StopBits = UART_STOPBITS_1;         //停止位
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    if (HAL_UART_Init(&huart1) != HAL_OK)
        return pdFAIL;
    
    //start usart1 interrupt.
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
    HAL_NVIC_EnableIRQ(USART1_IRQn);			
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 1);	
    
    return pdPASS;    
}
```
### **8.2.2 USART的中断收发**



### **8.2.3 USART的DMA+空闲中断接口，DMA发送**


### **8.2.4 模拟UART进行数据输出**