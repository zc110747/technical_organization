# **单片机总结系列(一) 综述和内核说明**

# **1.综述**
嵌入式系统是由主控芯片(MCU, DSP或SOC)，电源，外围器件(SDRAM，EPPROM，传感器，SD Card, Phy, CAN-Controller，驱动芯片等)共同实现的具有外部数据采集，处理和控制输出的综合系统。<br />
在一个完整的产品中，主控芯片往往负责处理数据采集(ADC, I/O Input，触摸输入), 存储管理(Nand-Flash, Nor-Flash, EPPROM), 外部器件交互(SPI，I2C), 系统间通讯(CAN, USART/RS432/RS485, MII/RMII等)， 功能输出(PWM, I/O output, DAC，UI显示输出等)，以硬件为基础，驱动和应用为内核，实现我们眼中各种复杂的产品。虽然驱动只是整个产品中很小的一部分，但没有驱动，其它所有的功能也是无根之萍。深入理解和掌握芯片相关的应用和驱动开发，对于未来提高也至关重要。<br />
在本系列将以STM32F429IGT6芯片为例（也适用于ST的其它芯片，当然理解后对于非ST的芯片，也可以更好的应用)。对于MCU芯片来说，由以下几部分组成.<br />

1. 内核Core和调试系统，这部分由ARM来定义和设计(如系统的架构，支持的指令集，流水线机制，内存模型)，一般通过内核IP的形式提供给芯片厂商.
2. 实现具体功能的外设模块，包含SPI，I2C, CAN，SDIO, USB等，这些模块由专业的IP厂商或者芯片厂商自行设计开发，并通过各类总线(AHB, APB，总线矩阵等)与内核连接实现具体功能。<br />
3. 内存模型管理，芯片需要提供数据存储和进行处理的存储空间，按照功能可以分为ROM(只读存储器)，用于存储代码和数据，可以在掉电后保存，RAM(随机存取存储器)可以支持系统运行时实时修改。其中ROM常见的有内部FLASH，外部的Epprom, NandFlash和NorFlash， RAM则有内部的SRAM，外部的SDRAM, PSARM, 此外对于更高端的芯片，往往还会支持I-Cache和D-Cache, 满足更高性能的需求。
4. 时钟，电源管理和复位系统，为了使芯片能够正常工作，还需要有统筹管理所有模块的电源和时钟系统。主要负责上电时序，提供系统和模块工作的电压和时钟，寄存器的读取、修改和复位都依赖时钟的触发，这也是我们在使用大部分外设模块时都需要先使能对应时钟的原因，这部分由模拟模块构建，并依赖数字模块控制，是芯片设计最关键的一环。作为开发者，涉及并不多，在低功耗需求开发时需要考虑。

对于本系列的文章，将使用HAL库版本去讲解，但不一定全部使用ST封装的接口，ST的设计抽象化做的还可以，但是部分过渡封装，很多时候我们开发中并不需要处理所有中断，另外很多库接口的超时是直接基于系统时钟进行硬等待，在初始化时使用还好，在循环中使用效率就很差，不过这里说下为什么使用HAL库，主要原因有以下几点。<br />

1. HAL库可以由STM32CubeMX直接生成，从管脚配置和模块功能都能很好的约束控制，避免出现人为实现的错误。<br />
2. 对于比较新的芯片(F4, F7以及G系列)，ST公司仅提供HAL库(包含HAL和LL)，而使用寄存器对于复杂模块无论从开发还是后期维护都是难题，因此不建议使用。<br />

上述就是我选择HAL的原因，其实这也是未来的趋势，像我使用过的英飞凌，TI这些公司的编译软件也在支持图形+支持包生成代码的工具，可以极快速的构建支持USB，CAN，网络或电机控制驱动的代码，如果有配套的开发板，甚至可以一行代码不改，实现以前大概要很久才能调试成功的功能，例如我曾经14年左右移植调试LWIP，参考大量资料，断断续续花了一个多月左右才调试稳定运行TCP应用，而就在去年，使用英飞凌的Dave工具，通过直接生成，修改下配置，仅一天就调整成基本可以直接运行的LWIP应用，可以说节省了大量的精力。<br />
很多从业者可能又要说了，驱动代码，甚至RTOS和LWIP，USB这些复杂的代码都可以直接生成，那作为单片机开发的意义是什么，其实可以归类以下几点。<br />

1. 开发中模块功能不正常时，能结合软件，硬件，配合设备(如电压表，逻辑分析仪，示波器)进行分析。这是经验积累的问题，例如I2C要带外部上拉，CAN硬件上要有终端匹配电阻，如何确定断路，短路，还是电阻，器件损坏，虽然看似是电子工程师的工作，但即使比较大的团队，电子工程师也无法时刻帮你分析，理解软硬件，可以快速让你去定性是软件还是硬件问题，在针对性处理，事半功倍。<br />
2. 适配不同的外部器件驱动，如果产品硬件套用官方开发板，那例程demo移植下就可以了，不过产品中往往因为需求和成本的要求，使用不同的器件，如使用不同的cmos，spi-flash, 3-axis sensor，压力传感器，温/湿度传感器，这就需要在外设驱动基础上，进一步封装上层的模块驱动，而且因为硬件和使用场景差别，官方demo大部分情况也不能直接使用，需求根据设计和应用要求进行修改和调试。<br />
3. 完成与其它设备的交互，如有的设备支持网页和远程软件控制，就需要实现通讯协议(如http，mqtt，modbus等)；还有些支持蓝牙，ziggbee, wifi功能，既是使用相应的蓝牙，wifi模块，也需要移植调试相应的AT指令协议, 并在其上扩展定制命令；支持界面显示，要实现GUI界面和触摸控制。有时因为产品的功能需求，也需要实现私有的协议。<br />
4. 应对不同行业中的产品应用需求，实现具体的功能，例如数据的存储管理(备份和容错恢复机制), 日志记录，在线升级，运动控制(位置，速度)，温湿度度控制，还有安全，保护机制, 异常的处理，这部分是和行业息息相关，对于各种突发情况都要有相应的处理机制，这部分往往在工作实践时才能够了解。<br />

这里举个产品中应用的例子，在工业应用领域，经常使用POT(线性的滑动变阻器)来进行位置的计算和行程限制，这种应用很简单，确定零点和满量程的ADC值记录在代码中，然后读取当前ADC值，按照比例反算下行程中的位置，看起来并不困难。但如果有量产经验，就会发现这个机制是有隐藏问题的，当只有一台开发设备时，可以实现很精确的位置计算，但当产品批量时，可能因为POT本身产品的差异，基准电压的偏差，供电电压的差异，那一套参数就适配不了所有的设备，这时就要考虑提供校准方案，如比较常用的两点校准，根据物理的零点和满量程位置，满足条件就记录下ADC值，后续就校准的参数进行计算，校准方案在嵌入式产品中有很多的应用，而这部分知识只有自己实践中才会了解，区分资深和入门的一个重要的方面。

# **2.内核概览**
基于Cortex-M4F内核设计，包含以下特点:<br />

1. 是32位的处理器内核，也就是说内部的寄存器和数据位宽都是32位的.
2. 采用哈佛结构，具有独立的数据总线和指令总线，内核可以同时读取数据和指令，提高了效率.
3. 支持MPU, 存储器保护单元, 可以控制对于不同memory的访问权限(需要芯片设计启用).
4. 支持DSP指令集, 能够加速浮点运算.
5. 支持handler和thread两种模式，分别用于表示异常服务例程和普通用户程序的代码，另外也支持特权分级，privileged和unprivileged模式, 其中handler模式只支持privileged模式.

## **2.1 通用寄存器**
Cortex-M4处理器拥有R0-R15寄存器组<br />

1. R0-R12为32位通用寄存器，用于数据操作。<br />
2. R13为堆栈指针寄存器，且同时指定两个堆栈指针:MSP(主堆栈指针)和PSP(进程堆栈指针)，并通过修改权限指向对应的堆栈指针，堆栈指针的最低两bit永远是0.<br />
3. R14为LR寄存器，主要在调用子程序时，存储返回地址.<br />
4. R15为PC寄存器，指向当前的程序地址.<br />
5. 特殊功能寄存器xPSR,用于记录ALU标志，管理中断以及修改系统的特权状态.<br />

这些寄存器的相关知识，主要在实现RTOS或者在调试hardfault时追踪，对于RTOS中，汇编指令如下<br />
```armasm
msr psp, r0	 #将psp指针值写入r0寄存器，并将当前堆栈切换到PSP
msr msp, r0	 #将msp指针值写入r0寄存器，并将当前堆栈切换到MSP
```
对于触发hardfault时，可以使用错误追踪库，则包含对上述寄存器的运用:https://github.com/armink/CmBacktrace<br />

## **2.2 中断向量控制器NVIC**
Cortex-M4内核支持NVIC中断向量控制器，其中最大支持240个可编程中断(由芯片厂商定义)，另外包含15个系统中断，这部分声明在startup_xxx.s启动文件中，例如stm32f4的定义如下:<br />
```s
    DCD     __initial_sp               ; Top of Stack
    DCD     Reset_Handler              ; Reset Handler          #复位中断
    DCD     NMI_Handler                ; NMI Handler            #不可屏蔽中断
    DCD     HardFault_Handler          ; Hard Fault Handler     #硬fault中断
    DCD     MemManage_Handler          ; MPU Fault Handler      #MPU访问异常
    DCD     BusFault_Handler           ; Bus Fault Handler      #总线错误异常
    DCD     UsageFault_Handler         ; Usage Fault Handler    #程序错误异常
    DCD     0                          ; Reserved
    DCD     0                          ; Reserved
    DCD     0                          ; Reserved
    DCD     0                          ; Reserved
    DCD     SVC_Handler                ; SVCall Handler         #系统SVC异常
    DCD     DebugMon_Handler           ; Debug Monitor Handler  #调试监视器异常
    DCD     0                          ; Reserved
    DCD     PendSV_Handler             ; PendSV Handler         #为系统设置的PendSVSS异常
    DCD     SysTick_Handler            ; SysTick Handler        #系统滴答定时器异常

    ; External Interrupts
    DCD     WWDG_IRQHandler            ; Window WatchDog
```
对于剩余240个中断，则由芯片厂商进行定义，当然也不是全部都存在，厂商根据外设的需求，可以自定义中断对应的线号, 如STM32F4来说，如头文件中WWDG_IRQn值为0，在中断向量表中就对应第一个外部中断WWDG_IRQHandler，在中断触发时，就通过查找在中断向量表中的偏移值，找到对应的中断函数，触发执行。<br />
另外对于Cortex-M4来说支持最大8位优先级，不同中断可以使用相同的优先级，这时根据在中断线号绝对先后执行顺序且互相不会打断。对于具体使用位数由芯片厂商定义，但是最少支持3bit，对于STM32F49IG设计上则支持4bit作为优先级，并进一步可以分类为抢占优先级和子优先级，其中抢占优先级更高的中断，可以打断低优先级的中断；子优先级只影响中断的执行顺序，不会打断现有中断执行。对于中断处理的函数由内核库提供(代码中的CMSIS库, 如core_cm4.h)提供，不过HAL库进行了封装，具体函数接口如下.<br />
```c
/*
设置中断向量的抢占优先级和子优先级
  *         @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority
  *                                    4 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority
  *                                    3 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority
  *                                    2 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority
  *                                    1 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority
  *                                    0 bits for subpriority
*/
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)

//设置中断的抢占优先级和子优先级，0最高，最低优先级位2^bit
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)

//使能中断
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)

//关闭中断
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)

//设置中断向量表位置
SCB->VTOR = SRAM_BASE | ADDRESS; 
```
对于一个模块需要开启中断，在模块使能正常工作后，以usart为例，需要进行如下操作.<br />
```c
//开启模块内部中断使能
__HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);

//设置中断对应的优先级
HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);

//使能中断
HAL_NVIC_EnableIRQ(USART1_IRQn);

//使能总中断
void __enable_irq(void);

//关闭总中断
void __disable_irq(void)

//定义中断的执行函数
void USART1_IRQHandler(void)
{
    uint8_t rx_data;
    
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE) != RESET)
    {
        //对于接收中断标志位，当读取DR值时自动清除，因此不需要软件再清除
        if(HAL_UART_Receive(&huart1, &rx_data, 1, 100) == HAL_OK)
        {
            //update data to application
        }
    }
}
```
如果中断未正常触发，就可以查看上述步骤是否有缺失。这里描述下检查的方法.<br />

1. 查看非中断模式下模块能否正常收发数据，确定模块是否正常配置, 包含时钟，GPIO，是否需要重映射，模块配置是否正确.<br />
2. 确定模块内部中断使能位是否置位。<br />
3. 确定NVIC中断使能位是否置位。<br />
4. 确定中断入口函数是否和启动文件内命名一致，如果没有对应中断函数，会停止在启动文件中。<br />
5. 如果上述4步骤仍然不触发，则判断是否关闭了总中断或者进行了中断屏蔽一直未开启。<br />

上述就是分析中断无法执行的主要方式，当中断未正常触发时，一般按照此流程分析中断的触发流程。

## **2.3 调试接口**
Cortex-M4F内核提供集成再在片上调试支持，包含以下接口。
```
● SWJ-DP：串行/JTAG 调试端口
● AHP-AP：AHB 访问端口
● ITM：指令跟踪单元
● FPB：Flash 指令断点
● DWT：数据断点触发
● TPUI：跟踪端口单元接口（大封装上提供，其中会映射相应引脚）
● ETM：嵌入式跟踪宏单元（大封装上提供，其中会映射相应引脚）
```
基于调试工具，支持JTAG-DP(5脚)和SW-DP(2脚)模式，ETM嵌入式追踪单元使用TDI和TDO脚，与JTAG-DP模式下的JTDO和JTDI下一致。所以不能使用ETM作为打印调试。<br />

### **2.3.1 SEGGER-jlink调试**
对于调试打印，对于jlink，可以使用segger驱动内提供的SEGGER_RTT进行移植，将内部的**SEGGER_RTT.c**, **SEGGER_RTT_ASM_ARMv7M.S**和**SEGGER_RTT_printf.c**添加到代码中，添加头文件路径，即可使用**SEGGER_RTT.h**即可使用调试接口。<br />
```c
//安装地址
..\SEGGER\JLink\Samples\RTT

//BufferIndex - 写入port，目前为0
//pBuffer - 数据的起始指针
//NumBytes - 数据长度
unsigned SEGGER_RTT_Write (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);

//类似printf的可变输入函数
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
```
使用工具J-Link RTT Client或J-Link RTT Viewer即可进行调试操作。<br />

### **2.3.2 ST-Link调试**
对于ST-Link, 则可以使用ETM嵌入式跟踪宏单元进行调试，不过要确定以下设计.<br />
1. 使用SW-DP连接方式<br />
2. 确定TDI和TDO与芯片连接(比较简单的测试方法，支持JTAG模式连接).<br />

然后在代码中即可使用ETM接口进行跟踪调试。

```c
//需要在.c文件中声明ITM数据格式
volatile int32_t ITM_RxBuffer = ITM_RXBUFFER_EMPTY;

//ITM检查是否有数据读取
int32_t ITM_CheckChar (void);

//ITM读取数据
int32_t ITM_ReceiveChar (void);

//ITM发送数据
uint32_t ITM_SendChar (uint32_t ch);
```
之后可以使用调试接口下View->Serial Windows->Debug(printf) viewer进行输出，如果需要再非调试下查看，也可以使用STM32CubeProgrammer->SWV进行查看。<br />
上面从内核，NVIC和调试部分应用讲解内核信息，不过这也仅仅只是内核功能中常用的一部分，如果想继续深入了解，也可以参考其它嵌入式书籍, 配合深入学习。<br />

# 参考书籍

本系列参考书籍如下：

1. <Cortex-M3权威指南>  - 宋岩译 <br />
2. <Cortex™-M4 Devices Generic User Guide> <br />
3. <STM32F4x 参考手册> 
4. <STM32F4x 数据手册>


